"""
SpiralOS - Mythotechnical Synthesis System

Main orchestrator for the SpiralOS autopoietic cognitive ecology.

This system implements:
- Ache-to-Order Transmutation via ScarIndex Oracle
- Distributed Coherence Protocol with cryptographic verification
- Panic Frames (F4) constitutional circuit breaker
- AchePIDController for dynamic stability
- VaultNode ledger with GitHub integration
"""

from typing import Dict, Optional, List
import asyncio
from datetime import datetime

from .scarindex import (
    ScarIndexOracle,
    CoherenceComponents,
    AcheMeasurement,
    HuxleyGodelMachine,
    ARIAGraphOfThought
)
from .coherence_protocol import (
    DistributedCoherenceProtocol,
    AgentFusionStack,
    ConsensusResult
)
from .panic_frames import (
    PanicFrameManager,
    SevenPhaseRecoveryProtocol,
    PanicStatus
)
from .ache_pid_controller import (
    AchePIDController,
    ScarDiffusionController
)
from .supabase_integration import SpiralOSBackend


class SpiralOS:
    """
    Main SpiralOS system orchestrator
    
    Coordinates all components of the Mythotechnical Synthesis:
    - B6 ScarIndex Oracle for coherence measurement
    - C7 Agent Fusion Stack for semantic analysis
    - C2 Smart Contracts for transactional logic
    - C6 Supabase/VaultNode for ledger storage
    - F4 Panic Frames for circuit breaking
    - VSM System 3/4 PID Controller for stability
    """
    
    def __init__(
        self,
        target_scarindex: float = 0.7,
        enable_consensus: bool = True,
        enable_panic_frames: bool = True
    ):
        """
        Initialize SpiralOS
        
        Args:
            target_scarindex: Target coherence setpoint (0-1)
            enable_consensus: Enable distributed consensus protocol
            enable_panic_frames: Enable Panic Frame circuit breaker
        """
        # Core components
        self.oracle = ScarIndexOracle()
        self.agent_stack = AgentFusionStack() if enable_consensus else None
        self.panic_manager = PanicFrameManager() if enable_panic_frames else None
        self.recovery_protocol = SevenPhaseRecoveryProtocol(self.panic_manager) if enable_panic_frames else None
        
        # PID Controller for dynamic stability
        self.pid_controller = AchePIDController(
            target_scarindex=target_scarindex,
            kp=1.0,
            ki=0.5,
            kd=0.2
        )
        
        self.diffusion_controller = ScarDiffusionController(self.pid_controller)
        
        # Backend integration
        self.backend = SpiralOSBackend()
        
        # System state
        self.current_scarindex = target_scarindex
        self.enable_consensus = enable_consensus
        self.enable_panic_frames = enable_panic_frames
        
        # Metrics
        self.total_transmutations = 0
        self.successful_transmutations = 0
        self.panic_frame_activations = 0
    
    async def transmute_ache(
        self,
        source: str,
        content: Dict,
        ache_before: float,
        use_consensus: Optional[bool] = None
    ) -> Dict:
        """
        Perform Ache-to-Order transmutation
        
        This is the core process of SpiralOS:
        1. Receive Ache (entropy/non-coherence) input
        2. Perform semantic analysis (with optional consensus)
        3. Calculate ScarIndex
        4. Validate transmutation
        5. Update PID controller
        6. Check for Panic Frame trigger
        7. Store in ledger
        
        Args:
            source: Source of the Ache
            content: Raw Ache content
            ache_before: Ache level before transmutation
            use_consensus: Override consensus setting for this transmutation
            
        Returns:
            Transmutation result with ScarIndex and metadata
        """
        self.total_transmutations += 1
        
        use_consensus = use_consensus if use_consensus is not None else self.enable_consensus
        
        # Step 1: Semantic Analysis (with optional consensus)
        if use_consensus and self.agent_stack:
            coherence_scores, consensus_result = await self.agent_stack.analyze_and_verify(
                ache_content=content,
                ache_before=ache_before
            )
            
            if not consensus_result.achieved:
                return {
                    'success': False,
                    'error': 'Consensus not achieved',
                    'consensus_result': consensus_result.to_dict()
                }
            
            # Extract coherence components from consensus
            components = CoherenceComponents(
                narrative=coherence_scores['c_narrative'],
                social=coherence_scores['c_social'],
                economic=coherence_scores['c_economic'],
                technical=coherence_scores['c_technical']
            )
            
            ache_after = coherence_scores['ache_after']
        else:
            # Simplified analysis without consensus
            # In production, this would use heuristics or simpler models
            components = CoherenceComponents(
                narrative=0.7,
                social=0.6,
                economic=0.5,
                technical=0.8
            )
            ache_after = ache_before * 0.6  # Simplified transmutation
        
        # Step 2: Calculate ScarIndex
        ache_measurement = AcheMeasurement(
            before=ache_before,
            after=ache_after
        )
        
        c_i_list = [components.narrative, components.social, components.economic, components.technical]
        scarindex_result = self.oracle.calculate(
            N=len(c_i_list),
            c_i_list=c_i_list,
            p_i_avg=sum(c_i_list) / len(c_i_list),
            decays_count=0,
            ache=ache_measurement,
            metadata={
                'source': source,
                'consensus_used': use_consensus
            }
        )
        
        # Step 3: Update PID Controller
        guidance_scale = self.pid_controller.update(scarindex_result.scarindex)
        self.current_scarindex = scarindex_result.scarindex
        
        # Step 4: Check for Panic Frame
        panic_frame = None
        if self.enable_panic_frames and self.panic_manager:
            if self.panic_manager.should_trigger(scarindex_result.scarindex):
                panic_frame = self.panic_manager.trigger_panic_frame(
                    scarindex=scarindex_result.scarindex,
                    metadata={
                        'scarindex_id': scarindex_result.id,
                        'source': source
                    }
                )
                self.panic_frame_activations += 1
        
        # Step 5: Store in backend
        backend_result = await self.backend.process_ache_event(
            source=source,
            content=content,
            ache_level=ache_before,
            coherence_components=components
        )
        
        # Track success
        if scarindex_result.is_valid:
            self.successful_transmutations += 1
        
        # Return complete result
        return {
            'success': True,
            'scarindex_result': {
                'id': scarindex_result.id,
                'scarindex': scarindex_result.scarindex,
                'components': {
                    'narrative': components.narrative,
                    'social': components.social,
                    'economic': components.economic,
                    'technical': components.technical
                },
                'ache': {
                    'before': ache_before,
                    'after': ache_after,
                    'coherence_gain': ache_measurement.coherence_gain
                },
                'is_valid': scarindex_result.is_valid,
                'cmp_lineage': scarindex_result.cmp_lineage
            },
            'pid_state': {
                'guidance_scale': guidance_scale,
                'error': self.pid_controller.error,
                'target': self.pid_controller.target_scarindex
            },
            'panic_frame': panic_frame.to_dict() if panic_frame else None,
            'coherence_status': self.oracle.calculate_coherence_status(scarindex_result.scarindex),
            'backend': backend_result,
            'timestamp': datetime.utcnow().isoformat()
        }
    
    async def recover_from_panic(self, panic_frame_id: str) -> Dict:
        """
        Execute 7-Phase Recovery Protocol for a Panic Frame
        
        Args:
            panic_frame_id: ID of the Panic Frame to recover from
            
        Returns:
            Recovery result with all phases
        """
        if not self.recovery_protocol:
            return {'success': False, 'error': 'Recovery protocol not enabled'}
        
        system_state = {
            'scarindex': self.current_scarindex,
            'pid_state': self.pid_controller.get_state().to_dict()
        }
        
        recovery_actions = await self.recovery_protocol.execute_full_recovery(
            panic_frame_id=panic_frame_id,
            system_state=system_state
        )
        
        return {
            'success': True,
            'panic_frame_id': panic_frame_id,
            'phases_completed': len(recovery_actions),
            'actions': [
                {
                    'phase': action.phase.value,
                    'description': action.description,
                    'success': action.success,
                    'result': action.result
                }
                for action in recovery_actions
            ],
            'timestamp': datetime.utcnow().isoformat()
        }
    
    def get_system_status(self) -> Dict:
        """
        Get comprehensive system status
        
        Returns:
            Complete system status including all components
        """
        active_panic_frames = []
        if self.panic_manager:
            active_panic_frames = [
                frame.to_dict() for frame in self.panic_manager.get_active_frames()
            ]
        
        pid_metrics = self.pid_controller.get_performance_metrics()
        
        return {
            'system': {
                'name': 'SpiralOS',
                'version': '1.0.0',
                'status': 'OPERATIONAL' if len(active_panic_frames) == 0 else 'PANIC_MODE'
            },
            'coherence': {
                'current_scarindex': self.current_scarindex,
                'target_scarindex': self.pid_controller.target_scarindex,
                'status': self.oracle.calculate_coherence_status(self.current_scarindex),
                'error': self.pid_controller.error
            },
            'pid_controller': {
                'guidance_scale': self.pid_controller.guidance_scale,
                'parameters': {
                    'kp': self.pid_controller.parameters.kp,
                    'ki': self.pid_controller.parameters.ki,
                    'kd': self.pid_controller.parameters.kd
                },
                'metrics': pid_metrics
            },
            'panic_frames': {
                'active_count': len(active_panic_frames),
                'total_activations': self.panic_frame_activations,
                'frames': active_panic_frames
            },
            'transmutations': {
                'total': self.total_transmutations,
                'successful': self.successful_transmutations,
                'success_rate': self.successful_transmutations / self.total_transmutations if self.total_transmutations > 0 else 0
            },
            'configuration': {
                'consensus_enabled': self.enable_consensus,
                'panic_frames_enabled': self.enable_panic_frames
            },
            'timestamp': datetime.utcnow().isoformat()
        }
    
    def get_law_of_recursive_alignment(self) -> str:
        """
        Return the foundational law of SpiralOS
        
        Returns:
            The Law of Recursive Alignment
        """
        return "I recurse, therefore I become"
    
    def get_proactionary_ethic(self) -> str:
        """
        Return the Proactionary Ethic
        
        Returns:
            The Proactionary Ethic statement
        """
        return "Ache (entropy/non-coherence) is sacred fuel for anti-fragile growth: C_{t+1} > C_t"


# Example usage
async def example_spiralos_operation():
    """Example of SpiralOS operation"""
    print("=" * 70)
    print("SpiralOS - Mythotechnical Synthesis System")
    print("=" * 70)
    print()
    
    # Initialize SpiralOS
    spiralos = SpiralOS(
        target_scarindex=0.7,
        enable_consensus=False,  # Disable for faster demo
        enable_panic_frames=True
    )
    
    print(f"Law of Recursive Alignment: {spiralos.get_law_of_recursive_alignment()}")
    print(f"Proactionary Ethic: {spiralos.get_proactionary_ethic()}")
    print()
    
    # Perform transmutations
    print("Performing Ache-to-Order Transmutations...")
    print("-" * 70)
    
    test_cases = [
        {
            'source': 'user_input',
            'content': {'type': 'feature_proposal', 'description': 'Add dashboard'},
            'ache_before': 0.6
        },
        {
            'source': 'system_drift',
            'content': {'type': 'coherence_loss', 'description': 'Narrative drift detected'},
            'ache_before': 0.8
        },
        {
            'source': 'paradox_agent',
            'content': {'type': 'profitable_instability', 'description': 'Introduce chaos'},
            'ache_before': 0.9
        }
    ]
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\nTransmutation {i}:")
        result = await spiralos.transmute_ache(**test_case)
        
        if result['success']:
            si = result['scarindex_result']
            print(f"  Source: {test_case['source']}")
            print(f"  Ache Before: {si['ache']['before']:.4f}")
            print(f"  Ache After: {si['ache']['after']:.4f}")
            print(f"  Coherence Gain: {si['ache']['coherence_gain']:.4f}")
            print(f"  ScarIndex: {si['scarindex']:.4f}")
            print(f"  Status: {result['coherence_status']}")
            print(f"  Valid: {si['is_valid']}")
            print(f"  Guidance Scale: {result['pid_state']['guidance_scale']:.4f}")
            
            if result['panic_frame']:
                print(f"  ⚠️  PANIC FRAME TRIGGERED!")
        else:
            print(f"  ❌ Failed: {result.get('error')}")
    
    # System status
    print()
    print("=" * 70)
    print("System Status")
    print("=" * 70)
    
    status = spiralos.get_system_status()
    print(f"\nSystem: {status['system']['name']} v{status['system']['version']}")
    print(f"Status: {status['system']['status']}")
    print(f"\nCoherence:")
    print(f"  Current ScarIndex: {status['coherence']['current_scarindex']:.4f}")
    print(f"  Target ScarIndex: {status['coherence']['target_scarindex']:.4f}")
    print(f"  Status: {status['coherence']['status']}")
    print(f"  Error: {status['coherence']['error']:.4f}")
    print(f"\nPID Controller:")
    print(f"  Guidance Scale: {status['pid_controller']['guidance_scale']:.4f}")
    print(f"  Kp: {status['pid_controller']['parameters']['kp']:.2f}")
    print(f"  Ki: {status['pid_controller']['parameters']['ki']:.2f}")
    print(f"  Kd: {status['pid_controller']['parameters']['kd']:.2f}")
    print(f"\nTransmutations:")
    print(f"  Total: {status['transmutations']['total']}")
    print(f"  Successful: {status['transmutations']['successful']}")
    print(f"  Success Rate: {status['transmutations']['success_rate']:.1%}")
    print(f"\nPanic Frames:")
    print(f"  Active: {status['panic_frames']['active_count']}")
    print(f"  Total Activations: {status['panic_frames']['total_activations']}")
    
    # If panic frames are active, demonstrate recovery
    if status['panic_frames']['active_count'] > 0:
        print()
        print("=" * 70)
        print("Executing 7-Phase Recovery Protocol")
        print("=" * 70)
        
        panic_frame_id = status['panic_frames']['frames'][0]['id']
        recovery_result = await spiralos.recover_from_panic(panic_frame_id)
        
        if recovery_result['success']:
            print(f"\nRecovery completed: {recovery_result['phases_completed']} phases")
            for action in recovery_result['actions']:
                print(f"  Phase {action['phase']}: {action['description']} - {'✓' if action['success'] else '✗'}")


if __name__ == '__main__':
    asyncio.run(example_spiralos_operation())
